/* ------------------------------------------------------------------
  SURFACE (dynamic) â€” adaptive sRGB mixing schedule
  Steps determined by PRIMARY_SURFACE_SIZE constant.
  Progression generated by stepProgress curve and span constants.
  Guarantees uniqueness via duplicate nudge; first swatch is base color.
-------------------------------------------------------------------*/

import { Swatch } from './primary';
import { makeScaleLabels } from './labels';
import Color from 'color';
import {
  PRIMARY_SURFACE_SIZE,
  LIGHT_MODE_DARKEN_SPAN,
  DARK_MODE_DUPLICATE_NUDGE,
  LIGHT_MODE_DUPLICATE_NUDGE,
  DARK_MODE_LIGHTEN_SPAN,
} from './constants';
type ColorInstance = ReturnType<typeof Color>;
const toRGBAString = (c: { r: number; g: number; b: number }, alpha: number) => `rgba(${c.r},${c.g},${c.b},${alpha})`;

// Convert sRGB (0-255) to relative luminance components for OKLCH approximation (simplified).
// Non-linear step curve: heavier early change then easing out.
function stepProgress(i: number, count: number): number {
  const t = i / (count - 1);
  // Emphasize first half then smooth tail.
  const eased = t < 0.6 ? Math.pow(t / 0.6, 0.85) * 0.6 : 0.6 + (t - 0.6) * 0.4;
  return Math.min(1, eased);
}

export function makeSurfaceSwatches(
  color: string,
  lightMode = false,
  opts = {
    lightModeDarkenSpan: LIGHT_MODE_DARKEN_SPAN,
    darkModeLightenSpan: DARK_MODE_LIGHTEN_SPAN,
  }
): Swatch[] {
  const count = PRIMARY_SURFACE_SIZE;
  let parsed: ColorInstance;
  try {
    parsed = Color(color);
  } catch {
    parsed = Color('#000');
  }
  const obj = parsed.rgb().object();
  const baseAlpha = parsed.alpha();
  const baseColor = Color({ r: obj.r, g: obj.g, b: obj.b, alpha: baseAlpha });
  const swatches: Swatch[] = [];
  const labels = makeScaleLabels(count);
  const seen = new Set<string>();
  for (let i = 0; i < count; i++) {
    const label = labels[i];
    const factor = stepProgress(i, count); // 0..1 curve
    let c: ColorInstance;
    if (i === 0) {
      c = baseColor; // original
    } else {
      // Use incremental darken/lighten with small step to avoid overshooting to black/white.
      // Base per-step intensity influenced by overall curve; final multiplier modest.
      const maxDelta = lightMode ? opts.lightModeDarkenSpan : opts.darkModeLightenSpan; // total cumulative adjustment span
      const f = factor * maxDelta; // final desired overall adjustment proportion
      // We apply darken/lighten on the original color by f (color library treats darken as multiplying HSL lightness).
      c = lightMode ? baseColor.darken(f) : baseColor.lighten(f);
    }
    // Clamp channels into 0-255 and round
    const co = c.rgb().object();
    const roundedBase = { r: Math.round(co.r), g: Math.round(co.g), b: Math.round(co.b) };
    let rgba = toRGBAString(roundedBase, baseAlpha);
    // Uniqueness enforcement: if duplicate, apply tiny incremental adjustment
    let adj = 0;
    while (seen.has(rgba) && adj < 5) {
      const nudge = lightMode ? LIGHT_MODE_DUPLICATE_NUDGE : DARK_MODE_DUPLICATE_NUDGE;
      adj += nudge;
      c = lightMode ? c.darken(nudge) : c.lighten(nudge);
      const n = c.rgb().object();
      const rounded = { r: Math.round(n.r), g: Math.round(n.g), b: Math.round(n.b) };
      rgba = toRGBAString(rounded, baseAlpha);
    }
    seen.add(rgba);
    swatches.push({ label, color: rgba });
  }
  // Post condition: ensure strictly monotonic channel movement (approx) for light mode darkening and dark mode lightening.
  // (No mutation if already monotonic)
  return swatches;
}
